digraph reference_template {
    graph [
        goal="$goal",
        rankdir=LR,
        default_max_retry=3,
        retry_target="implement",
        fallback_retry_target="debate_consolidate",
        provenance_version="1",
        model_stylesheet="
            * { llm_model: DEFAULT_MODEL; llm_provider: DEFAULT_PROVIDER; }
            .hard { llm_model: HARD_MODEL; llm_provider: HARD_PROVIDER; }
            .verify { llm_model: VERIFY_MODEL; llm_provider: VERIFY_PROVIDER; }
            .branch-a { llm_model: BRANCH_A_MODEL; llm_provider: BRANCH_A_PROVIDER; }
            .branch-b { llm_model: BRANCH_B_MODEL; llm_provider: BRANCH_B_PROVIDER; }
            .branch-c { llm_model: BRANCH_C_MODEL; llm_provider: BRANCH_C_PROVIDER; }
        "
    ]

    // NOTE: Prompts in this template are abbreviated structural stubs.
    // Generated pipelines must use the full status-file contract from
    // Phase 4 (fallback path + nested-directory warning).
    exit  [shape=Msquare, label="Exit"]

    subgraph cluster_bootstrap {
        label="Bootstrap"
        start [shape=Mdiamond, label="Start"]

        // Toolchain gate — fail fast before LLM stages
        check_toolchain [
            shape=parallelogram,
            max_retries=0,
            tool_command="echo 'Replace with project-specific toolchain checks'; exit 0"
        ]

        // Spec expansion — bootstraps .ai/spec.md from vague input
        // Only node allowed to use auto_status=true (skip verify).
        expand_spec [
            shape=box,
            auto_status=true,
            prompt="Goal: $goal\n\nExpand the requirements into a detailed spec.\n\nWrite the spec to .ai/spec.md."
        ]

        // DoD routing — skip DoD generation on loop iterations
        check_dod [
            shape=box,
            label="DoD exists?",
            prompt="Check if .ai/definition_of_done.md exists and contains substantive criteria.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH.\noutcome=has_dod if yes, outcome=needs_dod if no."
        ]
    }

    subgraph cluster_dod {
        label="DoD Fanout"
        node [shape=box]

        // DoD fan-out: 3 branches, each a DIFFERENT provider via class
        dod_a [
            class="branch-a",
            prompt="Goal: $goal\n\nPropose a Definition of Done. Read .ai/spec.md.\nWrite to .ai/dod_a.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH.\noutcome=success"
        ]
        dod_b [
            class="branch-b",
            prompt="Goal: $goal\n\nPropose a Definition of Done. Read .ai/spec.md.\nWrite to .ai/dod_b.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH.\noutcome=success"
        ]
        dod_c [
            class="branch-c",
            prompt="Goal: $goal\n\nPropose a Definition of Done. Read .ai/spec.md.\nWrite to .ai/dod_c.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH.\noutcome=success"
        ]
        consolidate_dod [
            prompt="Goal: $goal\n\nSynthesize .ai/dod_a.md, .ai/dod_b.md, .ai/dod_c.md into a single consensus DoD.\nWrite to .ai/definition_of_done.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH.\noutcome=success"
        ]
    }

    subgraph cluster_planning {
        label="Planning Fanout"
        node [shape=box]

        // Planning fan-out: 3 branches with different providers
        // Each planner reads postmortem (if exists) to incorporate lessons.
        plan_a [
            class="branch-a",
            prompt="Goal: $goal\n\nCreate an implementation plan.\nRead .ai/spec.md, .ai/definition_of_done.md.\nIf .ai/postmortem_latest.md exists, incorporate its lessons.\nWrite to .ai/plan_a.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH.\noutcome=success"
        ]
        plan_b [
            class="branch-b",
            prompt="Goal: $goal\n\nCreate an implementation plan.\nRead .ai/spec.md, .ai/definition_of_done.md.\nIf .ai/postmortem_latest.md exists, incorporate its lessons.\nWrite to .ai/plan_b.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH.\noutcome=success"
        ]
        plan_c [
            class="branch-c",
            prompt="Goal: $goal\n\nCreate an implementation plan.\nRead .ai/spec.md, .ai/definition_of_done.md.\nIf .ai/postmortem_latest.md exists, incorporate its lessons.\nWrite to .ai/plan_c.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH.\noutcome=success"
        ]
        debate_consolidate [
            prompt="Goal: $goal\n\nSynthesize .ai/plan_a.md, .ai/plan_b.md, .ai/plan_c.md into a best-of-breed final plan.\nResolve conflicts. Ensure dependency order.\nIf .ai/postmortem_latest.md exists, verify the plan addresses every issue.\nWrite to .ai/plan_final.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH.\noutcome=success"
        ]
    }

    subgraph cluster_implement_verify {
        label="Implement And Verify"

        // Single-writer implementation — the only code-writing node
        implement [
            shape=box,
            class="hard",
            max_retries=2,
            prompt="Goal: $goal\n\nExecute .ai/plan_final.md. Read .ai/definition_of_done.md for acceptance criteria.\nIf .ai/postmortem_latest.md exists, prioritize fixing those issues.\n\nUse progressive compilation: get each module compiling before starting the next.\nLog progress to .ai/implementation_log.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH.\noutcome=success if build passes, outcome=fail with failure_reason, failure_class, and failure_signature otherwise."
        ]
        check_implement [shape=diamond, label="Implement OK?"]

        // Deterministic verification gates — tool nodes first, then semantic review
        verify_fmt [
            shape=parallelogram,
            tool_command="echo 'Replace with project-specific formatter check'; exit 0"
        ]
        check_fmt [shape=diamond, label="Fmt OK?"]

        verify_build [
            shape=parallelogram,
            tool_command="echo 'Replace with project-specific build check'; exit 0"
        ]
        check_build [shape=diamond, label="Build OK?"]

        verify_test [
            shape=parallelogram,
            tool_command="echo 'Replace with project-specific test check'; exit 0"
        ]
        check_test [shape=diamond, label="Tests OK?"]

        verify_artifacts [
            shape=parallelogram,
            tool_command="echo 'Replace with artifact hygiene check (include both .cargo-target* and .cargo_target* patterns)'; exit 0"
        ]
        check_artifacts [shape=diamond, label="Artifacts OK?"]

        verify_fidelity [
            shape=box,
            class="verify",
            prompt="Perform semantic fidelity review after deterministic checks pass.\n\nRead implementation outputs and verify behavior matches .ai/definition_of_done.md and .ai/spec.md.\nIf semantic gaps exist, outcome=fail with stable failure_reason code (for example semantic_fidelity_gap) and details.\n\nWrite results to .ai/verify_fidelity.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH.\noutcome=success if semantic review passes, outcome=fail with failure_reason and details."
        ]
        check_impl [shape=diamond, label="Impl OK?"]
    }

    subgraph cluster_review {
        label="Review Fanout"
        node [shape=box]

        // Review fan-out: 3 branches with different providers
        review_a [
            class="branch-a",
            prompt="Goal: $goal\n\nReview the implementation against .ai/definition_of_done.md.\nCheck build, completeness, correctness, tests.\nWrite review to .ai/review_a.md with APPROVED or REJECTED verdict.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH.\noutcome=success if meets DoD, outcome=fail with failure_reason and specific gaps."
        ]
        review_b [
            class="branch-b",
            prompt="Goal: $goal\n\nReview the implementation against .ai/definition_of_done.md.\nCheck build, completeness, correctness, tests.\nWrite review to .ai/review_b.md with APPROVED or REJECTED verdict.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH.\noutcome=success if meets DoD, outcome=fail with failure_reason and specific gaps."
        ]
        review_c [
            class="branch-c",
            prompt="Goal: $goal\n\nReview the implementation against .ai/definition_of_done.md.\nCheck build, completeness, correctness, tests.\nWrite review to .ai/review_c.md with APPROVED or REJECTED verdict.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH.\noutcome=success if meets DoD, outcome=fail with failure_reason and specific gaps."
        ]
        review_consensus [
            goal_gate=true,
            prompt="Goal: $goal\n\nSynthesize .ai/review_a.md, .ai/review_b.md, .ai/review_c.md.\nRead .ai/definition_of_done.md for criteria.\n\nIf 2+ reviewers APPROVED and no critical gaps: outcome=success.\nOtherwise: outcome=retry with failure_reason listing specific issues.\n\nWrite consensus to .ai/review_consensus.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH.\noutcome=success or outcome=retry with failure_reason."
        ]
    }

    subgraph cluster_postmortem {
        label="Postmortem"
        node [shape=box]

        // Postmortem — analyze failure, guide next iteration
        postmortem [
            prompt="Goal: $goal\n\nAnalyze why the implementation failed.\nRead .ai/review_consensus.md, .ai/review_a.md, .ai/review_b.md, .ai/review_c.md.\nRead .ai/implementation_log.md.\n\nProduce actionable guidance: root causes, what worked, what failed, specific fixes.\nThe next iteration must NOT start from scratch — preserve working code and fix gaps.\n\nWrite to .ai/postmortem_latest.md (overwrite previous).\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH.\noutcome=success"
        ]
    }

    // =========================================================================
    // Flow
    // =========================================================================

    // Linear start: toolchain -> spec -> DoD check
    start -> check_toolchain -> expand_spec -> check_dod

    // DoD fan-out (if needed)
    check_dod -> dod_a [condition="outcome=needs_dod"]
    check_dod -> dod_b [condition="outcome=needs_dod"]
    check_dod -> dod_c [condition="outcome=needs_dod"]
    dod_a -> consolidate_dod
    dod_b -> consolidate_dod
    dod_c -> consolidate_dod
    consolidate_dod -> plan_a
    consolidate_dod -> plan_b
    consolidate_dod -> plan_c

    // Skip to planning if DoD exists
    check_dod -> plan_a [condition="outcome=has_dod"]
    check_dod -> plan_b [condition="outcome=has_dod"]
    check_dod -> plan_c [condition="outcome=has_dod"]

    // Planning fan-in -> debate -> implement
    plan_a -> debate_consolidate
    plan_b -> debate_consolidate
    plan_c -> debate_consolidate
    debate_consolidate -> implement

    // Verify/check inner loop (tool gates first, semantic review last)
    implement -> check_implement
    check_implement -> verify_fmt [condition="outcome=success"]
    check_implement -> implement  [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_implement -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    verify_fmt -> check_fmt
    check_fmt -> verify_build [condition="outcome=success"]
    check_fmt -> implement    [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_fmt -> postmortem   [condition="outcome=fail && context.failure_class!=transient_infra"]

    verify_build -> check_build
    check_build -> verify_test  [condition="outcome=success"]
    check_build -> implement    [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_build -> postmortem   [condition="outcome=fail && context.failure_class!=transient_infra"]

    verify_test -> check_test
    check_test -> verify_artifacts [condition="outcome=success"]
    check_test -> implement        [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_test -> postmortem       [condition="outcome=fail && context.failure_class!=transient_infra"]

    verify_artifacts -> check_artifacts
    check_artifacts -> verify_fidelity [condition="outcome=success"]
    check_artifacts -> implement       [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_artifacts -> postmortem      [condition="outcome=fail && context.failure_class!=transient_infra"]

    verify_fidelity -> check_impl
    check_impl -> review_a [condition="outcome=success"]
    check_impl -> review_b [condition="outcome=success"]
    check_impl -> review_c [condition="outcome=success"]
    check_impl -> postmortem [condition="outcome=fail"]

    // Review fan-in -> consensus
    review_a -> review_consensus
    review_b -> review_consensus
    review_c -> review_consensus

    // Consensus routing: success -> exit, anything else -> postmortem
    review_consensus -> exit [condition="outcome=success"]
    review_consensus -> postmortem

    // Hill-climbing loop: postmortem -> re-plan -> re-implement -> re-review
    postmortem -> plan_a [loop_restart=true]
    postmortem -> plan_b [loop_restart=true]
    postmortem -> plan_c [loop_restart=true]
}
