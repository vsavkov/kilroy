digraph rogue_pipeline {
    graph [
        goal="a faithful WebAssembly browser port of Rogue 5.4.4 with a single-page ASCII terminal UI at demo/rogue/rogue-wasm/www/index.html",
        rankdir=LR,
        default_max_retry=3,
        retry_target="implement",
        fallback_retry_target="debate_consolidate",
        provenance_version="1",
        model_stylesheet="
            * { llm_model: minimax-m2.5; llm_provider: minimax; }
            .hard { llm_model: minimax-m2.5; llm_provider: minimax; }
            .verify { llm_model: minimax-m2.5; llm_provider: minimax; }
            .branch-a { llm_model: minimax-m2.5; llm_provider: minimax; }
            .branch-b { llm_model: moonshotai/kimi-k2.5; llm_provider: kimi; }
            .branch-c { llm_model: glm-5; llm_provider: zai; }
        "
    ]

    start [shape=Mdiamond, label="Start"]
    exit [shape=Msquare, label="Exit"]

    check_toolchain [
        shape=parallelogram,
        max_retries=0,
        tool_command="test -d demo/rogue/original-rogue && test -f demo/rogue/spec.md && test -f demo/rogue/DoD.md && command -v cargo >/dev/null && command -v rustc >/dev/null && command -v wasm-pack >/dev/null"
    ]
    check_toolchain_result [shape=diamond, label="Toolchain OK?"]

    seed_spec_and_dod [
        shape=parallelogram,
        tool_command="mkdir -p .ai && cp demo/rogue/spec.md .ai/spec.md && cp demo/rogue/DoD.md .ai/definition_of_done.md && test -s .ai/spec.md && test -s .ai/definition_of_done.md"
    ]

    plan_fanout [shape=component, label="Plan Fan-Out"]

    plan_a [
        shape=box,
        class="branch-a",
        prompt="Goal: $goal\n\nCreate an implementation plan.\nRead: .ai/spec.md, .ai/definition_of_done.md.\nAlso read: demo/rogue/original-rogue/rogue.h (constants, structs, macros), demo/rogue/original-rogue/extern.c (monster table, item tables, global data).\nIf .ai/postmortem_latest.md exists, incorporate its lessons.\nWrite: .ai/plan_a.md.\n\nPlan requirements:\n- Single-writer implementation strategy — one implement node writes all code.\n- Phased build: project scaffold and RNG first, then core data types, dungeon gen, items, monsters, combat, commands/IO, wizard mode, save/load, HTML/JS bridge, integration tests.\n- Deterministic verification order: fmt -> build -> test (unit + integration) -> deliverable checks.\n- Preserve exact mechanical fidelity constraints from spec (RNG formula, monster stats, combat math, item tables).\n- Plan must address all acceptance criteria from the DoD.\n- Plan must include all integration test scenarios from the DoD.\n- Plan must address the user-facing message inventory from the DoD — every message must be triggered and validated.\n- Reference the original C source files by name for each game system.\n\nStatus contract:\n- Write canonical status JSON to $KILROY_STAGE_STATUS_PATH.\n- If unavailable, write the same JSON to $KILROY_STAGE_STATUS_FALLBACK_PATH.\n- Use schema {\"status\":\"...\"}.\n- Do not write nested status.json files after cd.\n- For status=fail or status=retry include failure_reason and details.\n- Include failure_class when classifying deterministic vs transient failures.\n\nSet status=success when .ai/plan_a.md is written; otherwise status=fail."
    ]

    plan_b [
        shape=box,
        class="branch-b",
        prompt="Goal: $goal\n\nCreate an implementation plan.\nRead: .ai/spec.md, .ai/definition_of_done.md.\nAlso read: demo/rogue/original-rogue/rogue.h (constants, structs, macros), demo/rogue/original-rogue/extern.c (monster table, item tables, global data).\nIf .ai/postmortem_latest.md exists, incorporate its lessons.\nWrite: .ai/plan_b.md.\n\nPlan requirements:\n- Single-writer implementation strategy — one implement node writes all code.\n- Phased build: project scaffold and RNG first, then core data types, dungeon gen, items, monsters, combat, commands/IO, wizard mode, save/load, HTML/JS bridge, integration tests.\n- Deterministic verification order: fmt -> build -> test (unit + integration) -> deliverable checks.\n- Preserve exact mechanical fidelity constraints from spec (RNG formula, monster stats, combat math, item tables).\n- Plan must address all acceptance criteria from the DoD.\n- Plan must include all integration test scenarios from the DoD.\n- Plan must address the user-facing message inventory from the DoD — every message must be triggered and validated.\n- Reference the original C source files by name for each game system.\n\nStatus contract:\n- Write canonical status JSON to $KILROY_STAGE_STATUS_PATH.\n- If unavailable, write the same JSON to $KILROY_STAGE_STATUS_FALLBACK_PATH.\n- Use schema {\"status\":\"...\"}.\n- Do not write nested status.json files after cd.\n- For status=fail or status=retry include failure_reason and details.\n- Include failure_class when classifying deterministic vs transient failures.\n\nSet status=success when .ai/plan_b.md is written; otherwise status=fail."
    ]

    plan_c [
        shape=box,
        class="branch-c",
        prompt="Goal: $goal\n\nCreate an implementation plan.\nRead: .ai/spec.md, .ai/definition_of_done.md.\nAlso read: demo/rogue/original-rogue/rogue.h (constants, structs, macros), demo/rogue/original-rogue/extern.c (monster table, item tables, global data).\nIf .ai/postmortem_latest.md exists, incorporate its lessons.\nWrite: .ai/plan_c.md.\n\nPlan requirements:\n- Single-writer implementation strategy — one implement node writes all code.\n- Phased build: project scaffold and RNG first, then core data types, dungeon gen, items, monsters, combat, commands/IO, wizard mode, save/load, HTML/JS bridge, integration tests.\n- Deterministic verification order: fmt -> build -> test (unit + integration) -> deliverable checks.\n- Preserve exact mechanical fidelity constraints from spec (RNG formula, monster stats, combat math, item tables).\n- Plan must address all acceptance criteria from the DoD.\n- Plan must include all integration test scenarios from the DoD.\n- Plan must address the user-facing message inventory from the DoD — every message must be triggered and validated.\n- Reference the original C source files by name for each game system.\n\nStatus contract:\n- Write canonical status JSON to $KILROY_STAGE_STATUS_PATH.\n- If unavailable, write the same JSON to $KILROY_STAGE_STATUS_FALLBACK_PATH.\n- Use schema {\"status\":\"...\"}.\n- Do not write nested status.json files after cd.\n- For status=fail or status=retry include failure_reason and details.\n- Include failure_class when classifying deterministic vs transient failures.\n\nSet status=success when .ai/plan_c.md is written; otherwise status=fail."
    ]

    debate_consolidate [
        shape=box,
        prompt="Goal: $goal\n\nCreate the final executable plan.\nRead: .ai/spec.md and .ai/definition_of_done.md.\nRead fanout outputs by first loading $KILROY_LOGS_ROOT/plan_fanout/parallel_results.json and then reading <worktree_dir>/.ai/plan_a.md, <worktree_dir>/.ai/plan_b.md, <worktree_dir>/.ai/plan_c.md from each branch. If parallel_results.json is missing, fall back to .ai/plan_a.md, .ai/plan_b.md, .ai/plan_c.md in the current worktree.\nIf .ai/postmortem_latest.md exists, verify the plan addresses every issue.\nWrite: .ai/plan_final.md.\n\nPlan acceptance checks:\n- Covers all required deliverables including demo/rogue/rogue-wasm/www/index.html.\n- Addresses all DoD acceptance criteria.\n- Includes all integration test scenarios from the DoD.\n- Addresses the user-facing message inventory from the DoD.\n- Includes deterministic verification gates before semantic review.\n- Preserves exact-fidelity constraints (RNG, monster stats, combat math, item tables).\n- Includes wizard mode implementation and wizard-assisted gameplay tests.\n\nStatus contract:\n- Write canonical status JSON to $KILROY_STAGE_STATUS_PATH.\n- If unavailable, write the same JSON to $KILROY_STAGE_STATUS_FALLBACK_PATH.\n- Use schema {\"status\":\"...\"}.\n- Do not write nested status.json files after cd.\n- For status=fail or status=retry include failure_reason and details.\n- Include failure_class when classifying deterministic vs transient failures.\n\nSet status=success when .ai/plan_final.md is complete; otherwise status=fail."
    ]

    implement [
        shape=box,
        class="hard",
        max_retries=2,
        prompt="Goal: $goal\n\nCheck first: if .ai/postmortem_latest.md exists, this is a REPAIR iteration.\n- Read .ai/postmortem_latest.md FIRST.\n- Fix ONLY the gaps it identifies.\n- Do NOT regenerate or rewrite systems already marked as working.\n- Preserve all passing code and tests.\nOtherwise, this is a fresh implementation: execute .ai/plan_final.md.\n\nIn both cases:\n- Read: .ai/spec.md, .ai/definition_of_done.md, .ai/plan_final.md.\n- Read original C source at demo/rogue/original-rogue/ as the authoritative reference for all game systems.\n- Write: source files under demo/rogue/rogue-wasm/ and .ai/implementation_log.md.\n\nImplementation constraints:\n- Exact mechanical fidelity to Rogue 5.4.4: RNG (seed*11109+13849), all 26 monster stats from extern.c, combat formula (swing/roll_em), item probability tables, dungeon generation algorithm, daemon/fuse system.\n- All game systems including wizard mode: create object, level skip, teleport, map reveal, identify, food counter, coordinates, pack count, level objects, see-monsters, infinite charges.\n- Deterministic seed support for reproducible testing.\n- Browser-playable WASM: 80x24 ASCII grid, monospace font, dark background, keyboard input, localStorage save/load.\n- Deliverable page at demo/rogue/rogue-wasm/www/index.html.\n- Write all integration test scenarios from the DoD (IT-1 through IT-9), using wizard mode as the test harness where specified.\n- Implement every user-facing message from the DoD's message inventory (MSG-1 through MSG-196).\n- Use progressive compilation: get each module compiling before starting the next.\n\nStatus contract:\n- Write canonical status JSON to $KILROY_STAGE_STATUS_PATH.\n- If unavailable, write the same JSON to $KILROY_STAGE_STATUS_FALLBACK_PATH.\n- Use schema {\"status\":\"...\"}.\n- Do not write nested status.json files after cd.\n- For status=fail or status=retry include failure_reason and details.\n- Include failure_class when classifying deterministic vs transient failures.\n\nSet status=success when implementation is ready for checks.\nSet status=fail on deterministic coding/build blockers."
    ]
    check_implement [shape=diamond, label="Implement OK?"]

    fix_fmt [
        shape=parallelogram,
        max_retries=0,
        tool_command="cd demo/rogue/rogue-wasm && cargo fmt"
    ]
    verify_fmt [
        shape=parallelogram,
        tool_command="cd demo/rogue/rogue-wasm && cargo fmt --check"
    ]
    check_fmt [shape=diamond, label="Fmt OK?"]

    verify_build [
        shape=parallelogram,
        tool_command="cd demo/rogue/rogue-wasm && cargo build --target wasm32-unknown-unknown"
    ]
    check_build [shape=diamond, label="Build OK?"]

    verify_test [
        shape=parallelogram,
        tool_command="cd demo/rogue/rogue-wasm && cargo test"
    ]
    check_test [shape=diamond, label="Tests OK?"]

    verify_deliverable [
        shape=parallelogram,
        tool_command="test -f demo/rogue/rogue-wasm/www/index.html && grep -qi 'wasm\\|.wasm' demo/rogue/rogue-wasm/www/index.html && grep -qi 'monospace\\|courier\\|mono' demo/rogue/rogue-wasm/www/index.html"
    ]
    check_deliverable [shape=diamond, label="Deliverable OK?"]

    verify_artifacts [
        shape=parallelogram,
        tool_command="if { git diff --name-only; git ls-files --others --exclude-standard; } | grep -qE '(^|/)(target|node_modules|dist|\\.cargo-target|\\.cargo_target|pkg)(/|$)'; then echo artifact_paths_detected; exit 1; else exit 0; fi"
    ]
    check_artifacts [shape=diamond, label="Artifacts OK?"]

    verify_fidelity [
        shape=box,
        class="verify",
        prompt="Goal: $goal\n\nPerform semantic fidelity review after all deterministic checks have passed.\nRead: .ai/spec.md, .ai/definition_of_done.md, .ai/implementation_log.md, and the produced Rust source code under demo/rogue/rogue-wasm/src/.\nAlso read the original C source at demo/rogue/original-rogue/ for comparison.\nWrite: .ai/verify_fidelity.md.\n\nVerification approach:\n1. Read .ai/definition_of_done.md. For each AC group, verify the Rust implementation satisfies every criterion by comparing against the C original.\n2. Verify all integration test scenarios from the DoD (IT-1 through IT-9) are implemented as cargo test tests.\n3. Verify every user-facing message from the DoD's message inventory (MSG-1 through MSG-196) is present in the Rust code with correct trigger conditions.\n4. Verify at least one integration test loads the HTML deliverable in a browser (the delivery form test).\n5. Spot-check fidelity: RNG formula, monster stats table, combat formulas, item probability tables, dungeon gen algorithm, daemon/fuse timing against C source.\n6. No placeholder or TODO implementations for any in-scope game system.\n\nStatus contract:\n- Write canonical status JSON to $KILROY_STAGE_STATUS_PATH.\n- If unavailable, write the same JSON to $KILROY_STAGE_STATUS_FALLBACK_PATH.\n- Use schema {\"status\":\"...\"}.\n- Do not write nested status.json files after cd.\n- For status=fail or status=retry include failure_reason and details.\n- Include failure_class when classifying deterministic vs transient failures.\n\nIf status=fail, set failure_signature in meta to a sorted comma-separated list of the failed verification point numbers.\n\nSet status=success if all verification points pass; otherwise set status=fail with specific gaps listed."
    ]
    check_fidelity [shape=diamond, label="Fidelity OK?"]

    review_fanout [shape=component, label="Review Fan-Out"]

    review_a [
        shape=box,
        class="branch-a",
        prompt="Goal: $goal\n\nReview implementation completeness against .ai/definition_of_done.md and .ai/spec.md.\nRead: .ai/spec.md, .ai/definition_of_done.md, .ai/implementation_log.md, .ai/verify_fidelity.md.\nAlso read produced source code under demo/rogue/rogue-wasm/src/ and demo/rogue/rogue-wasm/www/.\nWrite: .ai/review_a.md with APPROVED or REJECTED verdict and concrete evidence.\n\nReview against all DoD acceptance criteria (AC-1 through AC-15), integration test scenarios (IT-1 through IT-9), and user-facing message inventory (MSG-1 through MSG-196).\n- For each AC group, verify the criterion is met with concrete evidence.\n- Verify all integration tests are implemented and would pass.\n- Verify user-facing messages are present with correct trigger conditions.\n- Verify at least one test loads the HTML deliverable in a browser.\n\nStatus contract:\n- Write canonical status JSON to $KILROY_STAGE_STATUS_PATH.\n- If unavailable, write the same JSON to $KILROY_STAGE_STATUS_FALLBACK_PATH.\n- Use schema {\"status\":\"...\"}.\n- Do not write nested status.json files after cd.\n- For status=fail or status=retry include failure_reason and details.\n- Include failure_class when classifying deterministic vs transient failures.\n\nSet status=success if APPROVED; set status=fail if REJECTED with specific gaps."
    ]

    review_b [
        shape=box,
        class="branch-b",
        prompt="Goal: $goal\n\nReview implementation completeness against .ai/definition_of_done.md and .ai/spec.md.\nRead: .ai/spec.md, .ai/definition_of_done.md, .ai/implementation_log.md, .ai/verify_fidelity.md.\nAlso read produced source code under demo/rogue/rogue-wasm/src/ and demo/rogue/rogue-wasm/www/.\nWrite: .ai/review_b.md with APPROVED or REJECTED verdict and concrete evidence.\n\nReview against all DoD acceptance criteria, integration test scenarios, and user-facing message inventory (see .ai/definition_of_done.md).\n- Focus on mechanical fidelity: compare Rust constants/formulas against original C source at demo/rogue/original-rogue/.\n- Verify all integration test scenarios (IT-1 through IT-9) are implemented.\n- Verify user-facing messages from the message inventory are present in code.\n- Check for TODO/placeholder implementations.\n\nStatus contract:\n- Write canonical status JSON to $KILROY_STAGE_STATUS_PATH.\n- If unavailable, write the same JSON to $KILROY_STAGE_STATUS_FALLBACK_PATH.\n- Use schema {\"status\":\"...\"}.\n- Do not write nested status.json files after cd.\n- For status=fail or status=retry include failure_reason and details.\n- Include failure_class when classifying deterministic vs transient failures.\n\nSet status=success if APPROVED; set status=fail if REJECTED with specific gaps."
    ]

    review_c [
        shape=box,
        class="branch-c",
        prompt="Goal: $goal\n\nReview implementation completeness against .ai/definition_of_done.md and .ai/spec.md.\nRead: .ai/spec.md, .ai/definition_of_done.md, .ai/implementation_log.md, .ai/verify_fidelity.md.\nAlso read produced source code under demo/rogue/rogue-wasm/src/ and demo/rogue/rogue-wasm/www/.\nWrite: .ai/review_c.md with APPROVED or REJECTED verdict and concrete evidence.\n\nReview against all DoD acceptance criteria and integration test scenarios (see .ai/definition_of_done.md).\n- Focus on gameplay completeness: can a player explore, fight, use items, descend, die, and win?\n- Verify wizard mode commands all function.\n- Verify save/load round-trips correctly.\n- Verify hunger/starvation works.\n- Check that the HTML deliverable renders correctly in a browser.\n- Verify user-facing messages from the message inventory appear with correct triggers.\n\nStatus contract:\n- Write canonical status JSON to $KILROY_STAGE_STATUS_PATH.\n- If unavailable, write the same JSON to $KILROY_STAGE_STATUS_FALLBACK_PATH.\n- Use schema {\"status\":\"...\"}.\n- Do not write nested status.json files after cd.\n- For status=fail or status=retry include failure_reason and details.\n- Include failure_class when classifying deterministic vs transient failures.\n\nSet status=success if APPROVED; set status=fail if REJECTED with specific gaps."
    ]

    review_consensus [
        shape=box,
        goal_gate=true,
        prompt="Goal: $goal\n\nSynthesize review outcomes into a single consensus.\nRead: .ai/spec.md and .ai/definition_of_done.md.\nRead fanout outputs by first loading $KILROY_LOGS_ROOT/review_fanout/parallel_results.json and then reading <worktree_dir>/.ai/review_a.md, <worktree_dir>/.ai/review_b.md, <worktree_dir>/.ai/review_c.md from each branch. If parallel_results.json is missing, fall back to .ai/review_a.md, .ai/review_b.md, .ai/review_c.md in the current worktree.\nWrite: .ai/review_consensus.md.\n\nConsensus policy:\n- status=success when at least two reviews APPROVED and no critical DoD acceptance criteria gap remains (all ACs satisfied, all ITs implemented, message inventory covered).\n- status=retry when specific remediable gaps exist (list them in failure_reason).\n- status=fail only for unrecoverable blocking issues.\n\nStatus contract:\n- Write canonical status JSON to $KILROY_STAGE_STATUS_PATH.\n- If unavailable, write the same JSON to $KILROY_STAGE_STATUS_FALLBACK_PATH.\n- Use schema {\"status\":\"...\"}.\n- Do not write nested status.json files after cd.\n- For status=fail or status=retry include failure_reason and details.\n- Include failure_class when classifying deterministic vs transient failures."
    ]

    postmortem [
        shape=box,
        prompt="Goal: $goal\n\nAnalyze latest failure and define the next repair iteration.\nRead: .ai/review_consensus.md and .ai/implementation_log.md.\nRead: .ai/definition_of_done.md to cross-reference which acceptance criteria failed.\nIf review fanout artifacts are needed, read $KILROY_LOGS_ROOT/review_fanout/parallel_results.json and corresponding <worktree_dir>/.ai/review_a.md, .ai/review_b.md, .ai/review_c.md.\nWrite: .ai/postmortem_latest.md.\n\nOutput must include:\n- Root cause: which specific ACs, ITs, or MSGs from the DoD failed and why.\n- What worked: preserve all passing game systems and tests.\n- What failed: specific code/test gaps with file paths.\n- Next changes: concrete repair actions (do not reset successful work).\n- Priority order: fix build-blocking issues first, then test failures, then fidelity gaps.\n\nStatus contract:\n- Write canonical status JSON to $KILROY_STAGE_STATUS_PATH.\n- If unavailable, write the same JSON to $KILROY_STAGE_STATUS_FALLBACK_PATH.\n- Use schema {\"status\":\"...\"}.\n- Do not write nested status.json files after cd.\n- For status=fail or status=retry include failure_reason and details.\n- Include failure_class when classifying deterministic vs transient failures.\n\nYour status reflects whether you completed the analysis, not the state of the implementation.\nSet status=success when .ai/postmortem_latest.md is written."
    ]

    // =========================================================================
    // Flow
    // =========================================================================

    // Bootstrap: toolchain gate -> seed spec+DoD -> planning
    start -> check_toolchain
    check_toolchain -> check_toolchain_result
    check_toolchain_result -> seed_spec_and_dod [condition="outcome=success"]
    check_toolchain_result -> check_toolchain [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_toolchain_result -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_toolchain_result -> postmortem

    seed_spec_and_dod -> plan_fanout

    // Planning fan-out -> debate -> implement
    plan_fanout -> plan_a
    plan_fanout -> plan_b
    plan_fanout -> plan_c
    plan_a -> debate_consolidate
    plan_b -> debate_consolidate
    plan_c -> debate_consolidate
    debate_consolidate -> implement [condition="outcome=success"]
    debate_consolidate -> postmortem [condition="outcome=fail"]
    debate_consolidate -> postmortem

    // Implement -> deterministic verify chain
    implement -> check_implement
    check_implement -> fix_fmt [condition="outcome=success"]
    fix_fmt -> verify_fmt
    check_implement -> implement [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_implement -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_implement -> postmortem

    verify_fmt -> check_fmt
    check_fmt -> verify_build [condition="outcome=success"]
    check_fmt -> implement [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_fmt -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_fmt -> postmortem

    verify_build -> check_build
    check_build -> verify_test [condition="outcome=success"]
    check_build -> implement [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_build -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_build -> postmortem

    verify_test -> check_test
    check_test -> verify_deliverable [condition="outcome=success"]
    check_test -> implement [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_test -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_test -> postmortem

    verify_deliverable -> check_deliverable
    check_deliverable -> verify_artifacts [condition="outcome=success"]
    check_deliverable -> implement [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_deliverable -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_deliverable -> postmortem

    verify_artifacts -> check_artifacts
    check_artifacts -> verify_fidelity [condition="outcome=success"]
    check_artifacts -> implement [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_artifacts -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_artifacts -> postmortem

    // Semantic fidelity review -> review fan-out
    verify_fidelity -> check_fidelity
    check_fidelity -> review_fanout [condition="outcome=success"]
    check_fidelity -> implement [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_fidelity -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_fidelity -> postmortem

    // Review fan-out -> consensus
    review_fanout -> review_a
    review_fanout -> review_b
    review_fanout -> review_c
    review_a -> review_consensus
    review_b -> review_consensus
    review_c -> review_consensus

    // Consensus routing: success -> exit, anything else -> postmortem
    review_consensus -> exit [condition="outcome=success"]
    review_consensus -> postmortem [condition="outcome=retry"]
    review_consensus -> postmortem [condition="outcome=fail"]
    review_consensus -> postmortem

    // Hill-climbing loop: postmortem -> toolchain check -> re-plan -> re-implement
    postmortem -> check_toolchain
}
