digraph rogue_pipeline {
    graph [
        goal="a faithful Rogue 5.4.4 C-to-Rust WebAssembly port with deterministic gameplay parity and a browser-playable 80x24 ASCII terminal at demo/rogue/rogue-wasm/www/index.html",
        rankdir=LR,
        default_max_retry=3,
        retry_target="implement",
        fallback_retry_target="debate_consolidate",
        provenance_version="1",
        model_stylesheet="
            * { llm_model: minimax-m2.5; llm_provider: minimax; }
            .hard { llm_model: minimax-m2.5; llm_provider: minimax; }
            .verify { llm_model: minimax-m2.5; llm_provider: minimax; }
            .branch-a { llm_model: minimax-m2.5; llm_provider: minimax; }
            .branch-b { llm_model: kimi-k2.5; llm_provider: kimi; }
            .branch-c { llm_model: glm-5; llm_provider: zai; }
        "
    ]

    start [shape=Mdiamond, label="Start"]
    exit  [shape=Msquare, label="Exit"]

    check_toolchain [
        shape=parallelogram,
        max_retries=0,
        tool_command="command -v cargo >/dev/null 2>&1 || { echo 'ERROR: missing required tool: cargo' >&2; exit 1; }; command -v wasm-pack >/dev/null 2>&1 || { echo 'ERROR: missing required tool: wasm-pack' >&2; exit 1; }; rustup target list --installed | grep -qx wasm32-unknown-unknown || { echo 'ERROR: missing rust target wasm32-unknown-unknown' >&2; exit 1; }; test -f demo/rogue/spec.md || { echo 'ERROR: missing demo/rogue/spec.md' >&2; exit 1; }; test -f demo/rogue/DoD.md || { echo 'ERROR: missing demo/rogue/DoD.md' >&2; exit 1; }; test -f demo/rogue/rogue-prompt.txt || { echo 'ERROR: missing demo/rogue/rogue-prompt.txt' >&2; exit 1; }; echo 'Rust and Rogue source inputs verified'"
    ]

    seed_authoritative_inputs [
        shape=parallelogram,
        max_retries=0,
        tool_command="mkdir -p .ai && cp demo/rogue/spec.md .ai/spec.md && cp demo/rogue/DoD.md .ai/definition_of_done.md && cp demo/rogue/rogue-prompt.txt .ai/rogue-prompt.txt && echo 'Seeded .ai/spec.md, .ai/definition_of_done.md, .ai/rogue-prompt.txt'"
    ]

    plan_fanout [shape=component, label="Plan Fan-Out"]

    plan_a [
        class="branch-a",
        prompt="Goal: $goal\n\nCreate an implementation plan for the Rogue WASM port.\nRead .ai/spec.md, .ai/definition_of_done.md, and .ai/rogue-prompt.txt.\nIf .ai/postmortem_latest.md exists, incorporate all unresolved issues from it.\n\nPlan requirements:\n- Keep the port mechanical and fidelity-first (no gameplay redesign).\n- Cover RNG, dungeon generation, monster data/AI, combat math, items, daemons/fuses, hunger, level progression, commands, display, save/load, and wizard mode.\n- Identify concrete file/module boundaries under demo/rogue/rogue-wasm/.\n- Sequence work in dependency order (core engine first, browser bridge after deterministic core behavior).\n- Include concrete verification points tied to the DoD acceptance criteria.\n\nWrite to .ai/plan_a.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path).\nIf unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH.\nDo not write nested status.json files after cd.\nUse canonical schema: {\"status\":\"...\"}.\nIf status is fail or retry, include failure_reason, details, and failure_class.\nSet status=success only after .ai/plan_a.md is written."
    ]

    plan_b [
        class="branch-b",
        prompt="Goal: $goal\n\nCreate an implementation plan for the Rogue WASM port.\nRead .ai/spec.md, .ai/definition_of_done.md, and .ai/rogue-prompt.txt.\nIf .ai/postmortem_latest.md exists, incorporate all unresolved issues from it.\n\nPlan requirements:\n- Keep the port mechanical and fidelity-first (no gameplay redesign).\n- Cover RNG, dungeon generation, monster data/AI, combat math, items, daemons/fuses, hunger, level progression, commands, display, save/load, and wizard mode.\n- Identify concrete file/module boundaries under demo/rogue/rogue-wasm/.\n- Sequence work in dependency order (core engine first, browser bridge after deterministic core behavior).\n- Include concrete verification points tied to the DoD acceptance criteria.\n\nWrite to .ai/plan_b.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path).\nIf unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH.\nDo not write nested status.json files after cd.\nUse canonical schema: {\"status\":\"...\"}.\nIf status is fail or retry, include failure_reason, details, and failure_class.\nSet status=success only after .ai/plan_b.md is written."
    ]

    plan_c [
        class="branch-c",
        prompt="Goal: $goal\n\nCreate an implementation plan for the Rogue WASM port.\nRead .ai/spec.md, .ai/definition_of_done.md, and .ai/rogue-prompt.txt.\nIf .ai/postmortem_latest.md exists, incorporate all unresolved issues from it.\n\nPlan requirements:\n- Keep the port mechanical and fidelity-first (no gameplay redesign).\n- Cover RNG, dungeon generation, monster data/AI, combat math, items, daemons/fuses, hunger, level progression, commands, display, save/load, and wizard mode.\n- Identify concrete file/module boundaries under demo/rogue/rogue-wasm/.\n- Sequence work in dependency order (core engine first, browser bridge after deterministic core behavior).\n- Include concrete verification points tied to the DoD acceptance criteria.\n\nWrite to .ai/plan_c.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path).\nIf unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH.\nDo not write nested status.json files after cd.\nUse canonical schema: {\"status\":\"...\"}.\nIf status is fail or retry, include failure_reason, details, and failure_class.\nSet status=success only after .ai/plan_c.md is written."
    ]

    debate_consolidate [
        prompt="Goal: $goal\n\nSynthesize planning fanout results into a single executable plan.\nRead .ai/spec.md, .ai/definition_of_done.md, .ai/rogue-prompt.txt, and .ai/postmortem_latest.md if present.\n\nFanout artifact contract:\n1) Read $KILROY_LOGS_ROOT/plan_fanout/parallel_results.json.\n2) For each branch worktree_dir, read .ai/plan_a.md, .ai/plan_b.md, and .ai/plan_c.md from those worktrees.\n3) If parallel_results.json is missing, fall back to local .ai/plan_a.md/.ai/plan_b.md/.ai/plan_c.md.\n\nOutput requirements:\n- Resolve conflicts and pick the best parts across all three plans.\n- Preserve fidelity constraints from the spec and DoD.\n- Produce phased, file-specific, dependency-ordered tasks.\n- Include verification checkpoints aligned to DoD AC identifiers.\n\nWrite to .ai/plan_final.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path).\nIf unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH.\nDo not write nested status.json files after cd.\nUse canonical schema: {\"status\":\"...\"}.\nIf status is fail or retry, include failure_reason, details, and failure_class.\nSet status=success only after .ai/plan_final.md is written."
    ]

    implement [
        shape=box,
        class="hard",
        max_retries=2,
        prompt="Goal: $goal\n\nCRITICAL REPAIR MODE CHECK:\nIf .ai/postmortem_latest.md exists, this is a repair iteration. Read it FIRST and fix ONLY the identified gaps. Do not restart from scratch. Preserve all working code and passing tests.\nIf .ai/postmortem_latest.md does not exist, execute .ai/plan_final.md as a fresh implementation.\n\nAlways read:\n- .ai/spec.md\n- .ai/definition_of_done.md\n- .ai/rogue-prompt.txt\n- .ai/plan_final.md\n\nImplementation requirements:\n- Work in demo/rogue/rogue-wasm/.\n- Keep behavior mechanically faithful to demo/rogue/original-rogue/.\n- Implement deterministic core logic before browser integration layers.\n- Ensure the deliverable path demo/rogue/rogue-wasm/www/index.html exists and loads the wasm module.\n- Log incremental progress and decisions to .ai/implementation_log.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path).\nIf unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH.\nDo not write nested status.json files after cd.\nUse canonical schema: {\"status\":\"...\"}.\n\nIf status is fail or retry, include:\n- failure_reason (short stable identifier)\n- details (full error/context)\n- failure_class (deterministic or transient_infra)\n- failure_signature (stable signature for this exact failure shape)\n\nSet status=success only when implementation changes are complete for this iteration; otherwise set fail with the required payload."
    ]

    check_implement [shape=diamond, label="Implement OK?"]

    fix_fmt [
        shape=parallelogram,
        max_retries=0,
        tool_command="test -d demo/rogue/rogue-wasm || { echo 'ERROR: demo/rogue/rogue-wasm missing' >&2; exit 1; }; cd demo/rogue/rogue-wasm && cargo fmt"
    ]

    verify_fmt [
        shape=parallelogram,
        max_retries=0,
        tool_command="test -d demo/rogue/rogue-wasm || { echo 'ERROR: demo/rogue/rogue-wasm missing' >&2; exit 1; }; cd demo/rogue/rogue-wasm && cargo fmt --check"
    ]

    check_fmt [shape=diamond, label="Fmt OK?"]

    verify_build [
        shape=parallelogram,
        tool_command="test -d demo/rogue/rogue-wasm || { echo 'ERROR: demo/rogue/rogue-wasm missing' >&2; exit 1; }; cd demo/rogue/rogue-wasm && cargo build --target wasm32-unknown-unknown"
    ]

    check_build [shape=diamond, label="Build OK?"]

    verify_test [
        shape=parallelogram,
        tool_command="test -d demo/rogue/rogue-wasm || { echo 'ERROR: demo/rogue/rogue-wasm missing' >&2; exit 1; }; cd demo/rogue/rogue-wasm && cargo test"
    ]

    check_test [shape=diamond, label="Tests OK?"]

    verify_deliverable [
        shape=parallelogram,
        max_retries=0,
        tool_command="test -f demo/rogue/rogue-wasm/www/index.html || { echo 'ERROR: missing deliverable demo/rogue/rogue-wasm/www/index.html' >&2; exit 1; }; grep -Eq '([.]wasm|pkg/)' demo/rogue/rogue-wasm/www/index.html || { echo 'ERROR: index.html does not reference wasm module' >&2; exit 1; }; echo 'deliverable path and wasm reference verified'"
    ]

    check_deliverable [shape=diamond, label="Deliverable OK?"]

    verify_artifacts [
        shape=parallelogram,
        max_retries=0,
        tool_command="bad_paths=$(git diff --name-only -- | rg '(^|/)(target|node_modules|dist|pkg|[.]cargo-target|[.]cargo_target)' || true); if [ -n \"$bad_paths\" ]; then echo 'ERROR: build artifacts in git diff:' >&2; echo \"$bad_paths\" >&2; exit 1; fi; echo 'artifact hygiene verified'"
    ]

    check_artifacts [shape=diamond, label="Artifacts OK?"]

    verify_fidelity [
        shape=box,
        class="verify",
        prompt="Goal: $goal\n\nPerform semantic fidelity review after deterministic checks pass.\nRead:\n- .ai/spec.md\n- .ai/definition_of_done.md\n- .ai/rogue-prompt.txt\n- .ai/implementation_log.md (if present)\n\nEvaluate fidelity against DoD/spec acceptance areas, including:\n- Build/format/test gates (AC-1.*)\n- Deliverable and browser behavior (AC-2.*, AC-12.*)\n- RNG and deterministic replay (AC-3.*, AC-15.*)\n- Dungeon generation (AC-4.*)\n- Monster/combat/item/daemon/hunger/level systems (AC-5.* through AC-10.*)\n- Command coverage and gameplay behavior (AC-11.*)\n- Save/load correctness (AC-13.*)\n- Wizard mode capabilities (AC-14.*)\n\nWrite a criterion-by-criterion PASS/FAIL report to .ai/verify_fidelity.md with concrete evidence and gaps.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path).\nIf unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH.\nDo not write nested status.json files after cd.\nUse canonical schema: {\"status\":\"...\"}.\n\nIf status is fail or retry, include:\n- failure_reason: semantic_fidelity_gap\n- details: specific failed criteria with evidence\n- failure_class: deterministic\n- failure_signature: sorted comma-separated failed criteria identifiers (for example AC-4.4,AC-6.2,AC-14.3)\n\nSet status=success only if all required criteria pass; otherwise set status=fail with full payload."
    ]

    check_impl [shape=diamond, label="Impl OK?"]

    review_fanout [shape=component, label="Review Fan-Out"]

    review_a [
        class="branch-a",
        prompt="Goal: $goal\n\nReview implementation quality and completeness against .ai/definition_of_done.md and .ai/spec.md.\nRead .ai/verify_fidelity.md and relevant changed files.\n\nProduce a strict review with:\n- Verdict: APPROVED or REJECTED\n- Criterion-by-criterion evidence\n- Explicit list of blocking gaps and risk areas\n\nWrite to .ai/review_a.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path).\nIf unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH.\nDo not write nested status.json files after cd.\nUse canonical schema: {\"status\":\"...\"}.\nIf status is fail or retry, include failure_reason, details, and failure_class.\nSet status=success only for APPROVED with no blocking gaps; otherwise status=fail."
    ]

    review_b [
        class="branch-b",
        prompt="Goal: $goal\n\nReview implementation quality and completeness against .ai/definition_of_done.md and .ai/spec.md.\nRead .ai/verify_fidelity.md and relevant changed files.\n\nProduce a strict review with:\n- Verdict: APPROVED or REJECTED\n- Criterion-by-criterion evidence\n- Explicit list of blocking gaps and risk areas\n\nWrite to .ai/review_b.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path).\nIf unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH.\nDo not write nested status.json files after cd.\nUse canonical schema: {\"status\":\"...\"}.\nIf status is fail or retry, include failure_reason, details, and failure_class.\nSet status=success only for APPROVED with no blocking gaps; otherwise status=fail."
    ]

    review_c [
        class="branch-c",
        prompt="Goal: $goal\n\nReview implementation quality and completeness against .ai/definition_of_done.md and .ai/spec.md.\nRead .ai/verify_fidelity.md and relevant changed files.\n\nProduce a strict review with:\n- Verdict: APPROVED or REJECTED\n- Criterion-by-criterion evidence\n- Explicit list of blocking gaps and risk areas\n\nWrite to .ai/review_c.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path).\nIf unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH.\nDo not write nested status.json files after cd.\nUse canonical schema: {\"status\":\"...\"}.\nIf status is fail or retry, include failure_reason, details, and failure_class.\nSet status=success only for APPROVED with no blocking gaps; otherwise status=fail."
    ]

    review_consensus [
        goal_gate=true,
        prompt="Goal: $goal\n\nSynthesize review fanout results into one consensus decision.\nRead .ai/definition_of_done.md and .ai/spec.md.\n\nFanout artifact contract:\n1) Read $KILROY_LOGS_ROOT/review_fanout/parallel_results.json.\n2) Read .ai/review_a.md, .ai/review_b.md, and .ai/review_c.md from each branch worktree_dir.\n3) If parallel_results.json is missing, fall back to local files.\n\nConsensus rule:\n- If at least two reviews are APPROVED and there are no critical unresolved gaps: status=success.\n- Otherwise: status=retry with a consolidated actionable gap list.\n\nWrite consensus output to .ai/review_consensus.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path).\nIf unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH.\nDo not write nested status.json files after cd.\nUse canonical schema: {\"status\":\"...\"}.\nIf status is fail or retry, include failure_reason, details, and failure_class.\nSet status=success or retry according to the consensus rule above."
    ]

    postmortem [
        shape=box,
        prompt="Goal: $goal\n\nAnalyze the latest failure and produce repair guidance for the next iteration.\nRead if present:\n- .ai/review_consensus.md\n- .ai/verify_fidelity.md\n- .ai/implementation_log.md\n\nAlso read fanout review outputs via:\n1) $KILROY_LOGS_ROOT/review_fanout/parallel_results.json\n2) each branch worktree_dir .ai/review_a.md/.ai/review_b.md/.ai/review_c.md\n(fallback to local files if parallel_results.json is missing).\n\nOutput requirements:\n- Identify root causes and failed acceptance criteria.\n- Separate what is already working from what must change.\n- Provide concrete, file-specific next actions.\n- Preserve hill-climbing behavior: do not recommend full restarts when repair is sufficient.\n\nWrite to .ai/postmortem_latest.md (overwrite previous).\n\nClassify next-step routing with status:\n- impl_repair: plan still valid; fix implementation gaps\n- needs_replan: plan quality is insufficient; regenerate planning fanout\n- needs_toolchain: environment/tooling blockers\n- fail with failure_class=transient_infra only when retrying tooling is likely to unblock\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path).\nIf unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH.\nDo not write nested status.json files after cd.\nUse canonical schema: {\"status\":\"...\"}.\nIf status is fail or retry, include failure_reason, details, and failure_class.\nSet status according to the routing classification after writing .ai/postmortem_latest.md."
    ]

    start -> check_toolchain

    check_toolchain -> seed_authoritative_inputs [condition="outcome=success"]
    check_toolchain -> check_toolchain [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_toolchain -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_toolchain -> postmortem

    seed_authoritative_inputs -> plan_fanout [condition="outcome=success"]
    seed_authoritative_inputs -> check_toolchain [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    seed_authoritative_inputs -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    seed_authoritative_inputs -> postmortem

    plan_fanout -> plan_a
    plan_fanout -> plan_b
    plan_fanout -> plan_c
    plan_a -> debate_consolidate
    plan_b -> debate_consolidate
    plan_c -> debate_consolidate
    debate_consolidate -> implement

    implement -> check_implement
    check_implement -> fix_fmt [condition="outcome=success"]
    check_implement -> implement [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_implement -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_implement -> postmortem

    fix_fmt -> verify_fmt
    verify_fmt -> check_fmt
    check_fmt -> verify_build [condition="outcome=success"]
    check_fmt -> implement [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_fmt -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_fmt -> postmortem

    verify_build -> check_build
    check_build -> verify_test [condition="outcome=success"]
    check_build -> implement [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_build -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_build -> postmortem

    verify_test -> check_test
    check_test -> verify_deliverable [condition="outcome=success"]
    check_test -> implement [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_test -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_test -> postmortem

    verify_deliverable -> check_deliverable
    check_deliverable -> verify_artifacts [condition="outcome=success"]
    check_deliverable -> implement [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_deliverable -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_deliverable -> postmortem

    verify_artifacts -> check_artifacts
    check_artifacts -> verify_fidelity [condition="outcome=success"]
    check_artifacts -> implement [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_artifacts -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_artifacts -> postmortem

    verify_fidelity -> check_impl
    check_impl -> review_fanout [condition="outcome=success"]
    check_impl -> implement [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_impl -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_impl -> postmortem

    review_fanout -> review_a
    review_fanout -> review_b
    review_fanout -> review_c
    review_a -> review_consensus
    review_b -> review_consensus
    review_c -> review_consensus

    review_consensus -> exit [condition="outcome=success"]
    review_consensus -> postmortem

    postmortem -> check_toolchain [condition="outcome=fail && context.failure_class=transient_infra"]
    postmortem -> implement [condition="outcome=impl_repair"]
    postmortem -> plan_fanout [condition="outcome=needs_replan"]
    postmortem -> check_toolchain [condition="outcome=needs_toolchain"]
    postmortem -> implement
}
